Goal         = MainClass { ClassDecl } EOF ;

MainClass    = CLASS ID LBRACE
                 PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN
                 LBRACE Statement RBRACE
               RBRACE ;

ClassDecl    = CLASS ID [ EXTENDS ID ] LBRACE { VarDecl } { MethodDecl } RBRACE ;

VarDecl      = Type ID SEMICOLON ;

MethodDecl   = PUBLIC Type ID LPAREN [ FormalList ] RPAREN LBRACE
                 { VarDecl }
                 { Statement }
                 RETURN Expression SEMICOLON
               RBRACE ;

FormalList   = Type ID { COMMA Type ID } ;

Type         = (INT LBRACKET RBRACKET)
             | BOOLEAN
             | INT
             | ID ;

Statement    = LBRACE { Statement } RBRACE
             | IF LPAREN Expression RPAREN Statement ELSE Statement
             | WHILE LPAREN Expression RPAREN Statement
             | SYSTEM_OUT_PRINTLN LPAREN Expression RPAREN SEMICOLON
             | ID ASSIGN Expression SEMICOLON
             | ID LBRACKET Expression RBRACKET ASSIGN Expression SEMICOLON ;

Expression   = LogicalAndExpr ;

NegationExpr       = NEGATION PrimaryExpr ;
LogicalAndExpr     = (NegationExpr | RelationalExpr) { (AND | OR) (NegationExpr | RelationalExpr) } ;
RelationalExpr     = (NegationExpr | AdditiveExpr) { (LESS_THAN | GREATER_THAN | EQUAL | NOT_EQUAL | LESS_THAN_EQUAL | GREATER_THAN_EQUAL) (NegationExpr | AdditiveExpr) } ;
AdditiveExpr       = MultiplicativeExpr { (PLUS | MINUS) MultiplicativeExpr } ;
MultiplicativeExpr = PrimaryExpr { (TIMES | DIVIDE) PrimaryExpr } ;

PrimaryExpr  = INTEGER_LITERAL
             | TRUE
             | FALSE
             | ID
             | THIS
             | (NEW INT LBRACKET Expression RBRACKET)
             | (NEW ID LPAREN RPAREN)
             | (LPAREN Expression RPAREN)
             | (NEGATION PrimaryExpr)
             | (PrimaryExpr (DOT LENGTH | LBRACKET Expression RBRACKET | DOT ID LPAREN [ ExpList ] RPAREN)) ;

ExpList      = Expression { COMMA Expression } ;
